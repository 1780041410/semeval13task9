import nltk
import re

class shortestPaths():
    '''
    find the shortest path between two words in tree sentence base on nltk tree format
    it will return the list of labals (or words in case of dependncy tree)
    '''
    def get_lca_length(self, location1, location2):
        i = 0
        while i < len(location1) and i < len(location2) and location1[i] == location2[i]:
            i+=1
        return i

    def get_labels_from_lca(self, ptree, lca_len, location):
        labels = []
        for i in range(lca_len, len(location)):
            labels.append(ptree[location[:i]].label())
        return labels

    def parserShortestPath(self, ptree, text1, text2):
        leaf_values = ptree.leaves()
        leaf_index1 = leaf_values.index(text1)
        leaf_index2 = leaf_values.index(text2)

        location1 = ptree.leaf_treeposition(leaf_index1)
        location2 = ptree.leaf_treeposition(leaf_index2)

        #find length of least common ancestor (lca)
        lca_len = self.get_lca_length(location1, location2)
        #find path from the node1 to lca

        labels1 = self.get_labels_from_lca(ptree, lca_len, location1)
        #ignore the first element, because it will be counted in the second part of the path
        result = labels1[1:]
        #inverse, because we want to go from the node to least common ancestor
        result = result[::-1]

        #add path from lca to node2
        result = result + self.get_labels_from_lca(ptree, lca_len, location2)
        return result

    def findword(self,tree, word):
        #print("tree", type(tree), tree==word)
        #print(dir(tree))
        if isinstance(tree,nltk.tree.Tree):
            result=[tree.label()]
            if result[0] == word: #in case the node is not a leaf in the tree
                return []
            for stree in tree:
                subresult = self.findword(stree, word)
                #print("sub",subresult)
                if subresult is not None:
                    result.extend(subresult)
                    #print("result",result)
                    return result 
                    break
            return None
        elif isinstance(tree,str) and tree==word:
            return []
        else:
            return None


    def dependencyShortestPath(self,pt, word1, word2):
        '''
        word1 position in the tree must be left to word2!!
        all examples based on tree generated by malt parser:
        pt = mp.parse_one('I shot an elephant in my pajamas .'.split()).tree()
        (shot I (elephant an) (in (pajamas my)) .)
        '''
        path1 = self.findword(pt,word1)
        path2 = self.findword(pt,word2)

        if path1 is None:
            print(word1 + " is not in the tree")
            return None
        if path2 is None:
            print(word2 + " is not in the tree")
            return None

        # compare both paths
        #   -> find first different element
        j = 0
        '''
        case the tree is in->pajama->my
        shortestPath(pt, "my", "in")
        path1: ['shot', 'in', 'pajamas']
        path2: ['shot']
        ['pajamas']
        '''
        if word2 in path1:
            idx = path1.index(word2)
            return path1[idx+1:]

        if word1 in path2:
            idx = path2.index(word1)
            return path2[idx+1:]

        for i in range(1,min(len(path1),len(path2))):
            if path1[i] != path2[i]:
                j = i - 1
                break

        # now join both list from the jth element
        # we need to take into account the "order" of appearance in the tree
        # left or right, which is left to the other one, cuz it's tree will be reversed
        #  S VP NP Mary
        #  S VP NP Bob <-> Bob Np VP S
        #  always the reversed list goes first and that's it?
        sublist1 = path1[j:]
        #print("sublist1",sublist1)
        if j< len(path2)-1:
            j=j+1
        sublist2 = path2[j:]
        #print("sublist2",sublist2)
        sublist1.reverse()
        #print("sublist2",sublist2)
        shortestpath = sublist1 + sublist2

        return shortestpath


